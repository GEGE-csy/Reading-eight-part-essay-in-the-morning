// 会输出什么？
// / 5 5 5 5 5
// 为什么？
/**
 * / for循环是同步代码会直接执行，定时器里的代码是异步代码会先交给任务队列，等到同步代码执行后再执行
 * / 所以等到定时器里的代码执行的时候，就会找i，先在当前作用域中找，没找到就去上级作用域，这里var定义的i是在全局作用域中的
 * / 找到全局作用域中的i的时候，因为循环已经执行完了，这时候i的值是5，所以会输出5 5 5 5 5
 */
for(var i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i)
  }, i * 1000)
}
// / 解决方法1: 用let定义块级作用域中的i
for(let i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i)
  }, i * 1000)
}
// / 解决方法2: 在定时器外再嵌套一层函数作用域
// / 新的这个函数会产生函数作用域，循环5次就会产生5个作用域，每个作用域中的i都是外部传递进来的
// / 定时器在执行的时候就会找到他上层作用域中的每个i
for(var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(() => {
      console.log(i)
    }, i * 1000)
  })(i)
}