# 1.TCP/IP 四层网络模型

- 应用层（应用数据）
- 传输层（TCP 头+应用数据）
  有两个传输协议，TCP 和 UDP
  TCP：提供面向连接的、可靠的服务
  UDP：提供无连接的、不可靠的服务
- 网络层（IP 头+TCP 头+应用数据）
  最常使用 IP 协议，IP 协议将传输层的报文作为数据部分，再加上 IP 头部组成 IP 报文
- 网络接口层（帧头+IP 头+TCP 头+应用数据+帧尾）
  在 IP 头部前面加上 MAC 头部，封装成数据帧发送到网络上

# 2. 键入网址到网页显示，期间发生了什么？

1. 浏览器解析 url
   确定 web 服务器和文件名，生成 http 请求信息
2. 查找缓存
3. dns 解析
   查询服务器域名对应的 ip 地址
4. http 的传输工作交给操作系统中的协议栈
   (浏览器调用 socket 库来委托协议栈工作)
   协议栈上半部分是 TCP 和 UDP 协议，这两个传输协议接受浏览器的委托来收发数据
   下半部分是 IP 协议，控制网络包的收发
   1. 三次握手建立 TCP 连接
   2. tcp 协议给 http 报文加上 tcp 头部
   3. ip 协议给 tcp 报文加上 ip 头部
   4. 给 ip 报文加上 MAC 头部
   5. 网卡把网络包转成电信号，通过网线发送出去
5. 交换机转发网络包到路由器
6. 网络包通过多个路由器的转发到达服务器
7. 服务器处理网络包，把请求要访问的页面封装在 http 响应报文里
   http 响应报文再加上 tcp 头部、ip 头部、mac 头部，经过网卡、交换机、路由器被转发到客户端
8. 四次挥手断开 tcp 连接
9. 浏览器渲染页面
（这段可以考虑不说，也可以考虑说 🙊 浏览器的渲染过程还要说到）
<!-- 10. 浏览器解析 html，生成 DOM 树
10. 浏览器解析 CSS，构建 CSSOM 规则树
11. 根据 DOM 树和 CSSOM 规则树构建渲染树
12. 布局，根据渲染树计算节点的信息
13. 绘制-根据计算好的信息绘制页面 -->
14. js 引擎解析

# 3. 什么是 http 协议

http 是超文本传输协议
两点之间传输文字、图片、视频等超文本数据的约定规范

# 4.http 常见状态码

五类：

- 1xx
  接受的请求正在处理
- 2xx
  请求正常处理
  (200，一切正常)
- 3xx
  重定向相关的状态码
  (301 永久重定向，请求的资源已经不在了，要用新 url 再访问)
  (302 临时重定向，请求的资源还在，但临时用另一个 url 访问)
  (304 请求的资源在浏览器有缓存，可以直接使用)
- 4xx
  客户端错误
  (400 请求报文有错误，参数有误，域名不存在)
  (403 服务器禁止访问资源)
  (404 请求的资源在服务器上不存在)
- 5xx
  服务器错误
  (500 服务器内部错误)
  (501 客户端请求的功能还不支持)
  (503 服务器正在维护无法处理请求)

# 5. http 常见请求头和响应头

请求头：

- Accept：客户端可以接受的数据格式
- accept-encoding：客户端可以接受的压缩格式
- Connection：浏览器和服务器之间的连接类型
- Host：指定请求的服务器的域名

响应头：

- content-length
  服务器返回的响应数据的长度
- content-encoding
  服务器返回的响应数据使用了什么压缩格式
- content-type
  响应数据的格式

# 6. get 和 post 有什么区别

- get 请求是幂等的，对服务器资源不会产生影响，post 不是
- 浏览器一般会缓存 get 请求，不会缓存 post 请求
- post 请求在浏览器回退时会再次提交，get 不会
- get 请求通过 url 传参，post 请求参数放在请求体中
- get 请求的参数有长度限制，类型必须是 ASCII 字符，post 没有限制

# 7. http 缓存

强缓存和协商缓存

**强缓存：**
浏览器只要判断缓存没有过期，就直接使用浏览器的本地缓存，不用请求服务器

强缓存是利用 http 响应头中的`Expires`(绝对时间)和`Cache-Control`(相对时间)来实现的
如果响应头同时存在`Expires`和`Cache-Control`，`Cache-Control`优先级更高

（以 Cache-Control 为例）
浏览器第一次请求服务器资源，服务器返回资源时会在响应头加上`Cache-Control`，`Cache-Control`设置了过期时间
浏览器再次请求服务器资源时，会先计算资源是否过期，没有则使用缓存，否则请求服务器
服务器收到请求后，又会更新`Cache-Control`
（Expires 是拿当前时间和 Expires 比，Cache-Control 是拿第一次请求到现在的这段时间来比）

**协商缓存：**
浏览器要发送请求给服务器，询问本地缓存是否可用
协商缓存可以基于两种头部实现：

- 请求头中的`If-Modified-Since`和响应头中的`Last-Modified`
  浏览器第一次请求资源，服务器返回资源时会在响应头加上`Last-Modified`，表示资源在服务器上最后修改的时间
  浏览器再次请求资源时，会在请求头加上`If-Modified-Since`，值就是上一次的`Last-Modified`的值
  服务器会对比`If-Modified-Since`和资源最后修改的时间，判断资源是否有变化，如果变化了就返回新的资源，如果没变化就返回 304 让浏览器从本地读取资源
- 请求头中的`If-None-Match`和响应头中的`ETag`
  上面有一种缺点，如果服务器 1s 修改资源两次，也只会有一个`Last-Modified`值，可能不准确。
  **`ETag`是根据资源生成的唯一标识**
  浏览器再次请求资源时，会在请求头加上`If-None-Match`，值就是上一次的`ETag`的值
  服务器会对比`If-None-Match`和`ETag`，判断资源是否有变化，如果变化了就返回新的资源，如果没变化就返回 304 让浏览器从本地读取资源

`ETag`优先级高于`Last-Modified`

协商缓存需要配合强缓存中`Cache-Control`字段来使用，只有未命中强缓存时，才能发起带有协商缓存字段的请求

工作流程：

浏览器第一次发请求，缓存了服务器返回的资源和响应头

```json
浏览器要发请求 => 有本地缓存 => 判断 Cache-Control 是否过期
                              过期 => 判断是否有 ETag
                                      是 => 带 If-None-Match 向服务器请求
                                      否 => 判断是否有Last-Modified
                                            是 => 带If-Modified-Since 向服务器请求
                                            否 => 直接向服务器请求
                              未过期 => 直接使用本地缓存
```

# 8. http1.1 的优点和缺点

优点：
简单(报文格式简单 header+body、头部信息简单 key-value)
易扩展(请求方法、头字段等的组成都可以自定义和补充)
应用广泛(浏览器、app 等等都能用)

缺点：
无状态(完成有关联性操作的时候服务器无法确认身份，比如登陆下单支付)
明文传输(信息很容易被窃取)

# 9. http1.1 的性能如何

http 协议使用了`请求-应答`的通信模式，会造成 http 的性能问题
`队头堵塞`问题：
服务器要按照接收顺序来处理请求，如果处理某一个请求耗时长，后续的请求处理都会被阻塞，
会导致客户端一直请求不到数据

所以 http1.1 的性能比较一般，后续的 http2 和 http3 就是在优化 http 的性能

# 10. 什么是 https 协议

超文本传输安全协议
在 http 的基础上引入了一个安全层，使用 SSL/TLS 来加密数据包
因为 http 协议明文传输信息，存在一些信息被窃听、篡改、冒充的风险，
SSL/TLS 可以提供身份验证、信息加密等功能

# 11. http 和 https 有哪些区别

- http 信息明文传输，存在安全风险。https 能解决 http 不安全的缺陷，使用 SSL/TLS 来加密数据包
- https 要向 CA 申请数字证书，来安全传输公钥
- http 只需要经过 tcp 三次握手就可以进行 http 报文传输，但 https 经过 tcp 三次握手后还要经过 ssl/tls 握手，才能进行加密报文传输

# 12.https 解决了 http 的哪些问题，如何保证安全

窃听、篡改、冒充

https 采用混合加密的方式
对称加密+非对称加密
在通信建立前，采用非对称加密，生成一对公钥和私钥。服务器将公钥传给客户端，客户端用公钥加密一个密钥，再发送给服务器。服务器用私钥解密获得密钥。之后双方就利用这个密钥加密通信。

但是这个公钥的传递可能会被其他人截获，所以为了安全地传输公钥，就需要 CA 颁发的数字证书
CA 加密公钥和其他信息得到一个摘要，再利用 CA 的私钥对摘要进行加密得到签名
数字证书的内容就是原始信息和签名

我们电脑里会有 CA 的数字证书，通过这个拿到 CA 的公钥
然后用 CA 的公钥解密数字证书的签名，得到一个摘要
再根据证书的加密算法加密证书里的原始信息得到另一个摘要
比较这两个摘要是否一样，就能知道有没有中间人篡改证书

# 13. https 如何建立连接

（https 的握手过程/tls 握手过程）

1. 客户端向服务器发起加密通信请求，请求中包含客户端支持的 tls 协议版本、一个随机数、支持的
   加密方式
2. 服务器收到请求后，发出响应，响应中包含确认 tls 协议版本、一个随机数、确认加密方式、服务器的数字证书
3. 客户端利用操作系统中的 CA 公钥确认服务器数字证书的真实性，然后从数字证书获得服务器的公钥，加密一个新的随机数发给服务器
4. 客户端和服务器使用前面的三个随机数生成对话密钥，以后过程就用这个密钥来加密信息

# 14. http1.1 相比 http1.0 提高了什么性能

- http1.0 默认使用短连接，http1.1 默认使用长连接，长连接可以让多个请求复用一个 tcp 连接
- http1.1 支持管道网络传输，只要第一个请求发出去了，不必等响应就可以发出第二个请求

http1.1 性能瓶颈：

- 请求头/响应头不压缩，头部信息越多延迟越大，只能压缩 body
- 队头堵塞问题：服务器要按照请求顺序处理请求，如果处理某一个请求耗时长，后续的请求处理都会被阻塞
- 请求只能由客户端发送，服务器只能被动响应

# 15. http2 做了什么优化

- 头部压缩
  如果同时发多个请求的头部是一样的，会消除重复的部分
- 二进制格式
  头信息和数据体都是二进制
- 多路复用
  多个请求可以复用同一个 tcp 连接，一个 tcp 中的请求不分先后，可以同时被处理
  解决了 http 层的队头阻塞问题
- 服务器推送
  允许服务器主动向客户端发送资源

# 16.http3 做了什么优化

http2 虽然通过多个请求复用一个 tcp 连接，解决了 http 层的队头阻塞问题，
但是还存在 tcp 层的队头阻塞问题（一旦发生丢包，触发 tcp 的重传，所有 http 请求都会等待这个包重传回来）

http3 将 tcp 协议换成了 udp 协议，
采用基于 udp 协议的`quic协议`实现可靠性传输

- 不存在队头阻塞问题
  一个连接上并发传输多个数据流，一个流丢包了只会阻塞这个流，不会影响其他流
  和 http2 不同，http2 只要某个流中的数据包丢失了，其他流也会被影响
- 快速建立连接(快速握手)
- 流量控制、传输可靠等功能

# 17. http 请求报文的组成

- 请求行
  请求方法、url、http 协议版本
  GET 127.0.0.1 http/1.1
- 请求头
  一些键值对组成
- 空行
  空白的一行。。
- 请求体
  post、put 请求携带的数据

# 18. http 响应报文的组成

- 响应行
  http 协议版本 状态码 状态码原因
  http/1.1 200 OK
- 响应头
  一些键值对组成
- 空行
  空白的一行。。
- 响应体
  服务器响应的数据

# 19. url 有哪些组成部分

比如：https://juejin.cn:8080/post/6908327746473033741#heading-21

协议部分：`https:`，后面的`//`是分隔符
域名部分：`juejin.cn`
端口部分：`8080`，http 默认 80，https 默认 443（非必需）
虚拟目录部分（非必需）：域名后的第一个`/`到最后一个`/`。这里是`/post/`
文件名部分（非必需）：域名后最后一个`/`到`?`，如果没有`?`，则到`#`，如果没有`#`，则到结束都是文件名。这里是`6908327746473033741`
锚部分（非必需）：`#`开始到最后。这里是`heading-21`
参数部分（非必需）：`?`开始到`#`之间都是参数部分

# 20. TCP 和 UDP

- 连接
  TCP 是面向连接的，发送数据之前两端必须建立连接
  UDP 是面向无连接的，即刻传送数据
- 传输对象
  TCP 只支持单播传输，一个连接只有两个端点，不支持多播和广播传输
  UDP 支持单播、多播、广播传输（一对一、一对多、多对多）
- 传输方式
  TCP 面向字节流传输
  UDP 面向报文传输，一个个报文独立传输
- 可靠性
  TCP 是可靠传输，数据可以无差错、不丢失、按序到达
  UDP 是不可靠传输
- 拥塞控制和流量控制
  TCP 有拥塞控制和流量控制的机制，来保证数据运输的安全性
  UDP 没有，即使网络拥堵也不会影响 UDP 的发送速率
- 使用场景
  TCP：效率要求相对低，准确性要求相对高。比如文件传输
  UDP：效率要求相对高，准确性要求相对低。比如视频聊天

# 21. TCP 的重传机制

TCP 在传输数据的时候可能出现数据包丢失的情况，针对这种情况，会采用重传机制解决

超时重传：
发送数据时，设一个定时器，超过指定时间后，如果没有收到对方的确认应答，就会重新发送数据
（数据包丢失/确认应答丢失时都会）

# 22. TCP 的流量控制机制

流量控制是为了让发送方的发送速率不要太快，要让接收方来得及接收
具体表现在通过控制发送方的发送窗口大小，窗口大小就是每次传输数据的大小
发送方窗口大小根据接收方窗口大小来决定
发送方接收到接收方的确认报文后，会根据报文中接收方的窗口大小，来调整当前的发送窗口大小
当发送方收到一个零窗口时，必须停止发送数据，直到接收方重新发送一个不为零的窗口大小

# 23. TCP 的拥塞控制机制

拥塞控制是为了避免发送方的数据填满网络，当网络拥堵时，如果继续发送大量数据包，可能导致数据包丢失，这时候 tcp 会重传数据，但是重传会加重网络负担，导致更多丢包

发送方会维护一个拥塞窗口，大小根据网络拥堵程度变化
(发送方出现超时重传，就会认为网络出现拥堵)
发送方的窗口大小就取 min(拥塞窗口，接收窗口)

# 24. TCP 的三次握手

建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包，为了确认双方的发送和接收能力都正常

第一次握手：客户端给服务端发一个 SYN 报文，并随机初始化一个序号，表示向服务端发起连接
第二次握手：服务端收到客户端的 SYN 报文，也会回复一个 SYN 报文，并随机初始化一个序号，
把客户端的序号+1 作为确认应答号的值，表明自己收到了客户端的 SYN 报文
第三次握手：客户端收到服务端的 SYN 报文，会回复一个 ACK 报文，
把服务端的序号+1 作为确认应答号的值，表明自己收到了服务端的 SYN 报文，自己的序号也+1
这时候双方就建立好了连接

第三次握手可以携带数据，前两次握手不能携带数据

# 25. 为什么是三次握手？不是两次？

1. 同步双方初始序列号：两次握手没办法确认服务端的初始序号被对方成功接收 2.客户端发送的请求连接报文如果丢失了，会重传，第二个连接成功。
2. 第一个报文可能要一段时间才到达服务端，服务端发出确认就建立了新连接，
   会一直等待客户端发的数据，浪费资源

# 26. TCP 的四次挥手

第一次挥手：客户端发送一个 FIN 报文，并随机初始化一个序号，表示向服务端释放连接
第二次挥手：服务端收到客户端的 FIN 报文，会回复 ACK 报文，
把客户端的序号+1 作为确认应答号的值，表明自己收到了客户端的 FIN 报文
第三次挥手：如果服务端也想断开连接，服务端也发送一个 FIN 报文，并随机初始化一个序号
第四次挥手：客户端收到服务端的 FIN 报文，也会回复 ACK 报文，
把服务端的序号+1 作为确认应答号的值

服务端收到客户端的 ACK 报文，就处于关闭连接状态，客户端要再过一段时间后再进入关闭连接状态

# 27. TCP 粘包？怎么处理

信息在传输的时候可能会被分成多个 TCP 报文，
如果两条消息的某部分内容被分到同一个 TCP 报文，就是 TCP 粘包问题，
接收方不知道消息的边界，就无法分出有效的信息

解决方法：在两个信息之间插入特殊字符作为边界

# 28. 为什么 udp 不会粘包？

udp 是面向报文传输的，一次发送一个报文，会保留报文的边界，接收方就能够区分

# 29. 对 websocket 的理解

双向通信协议
浏览器和服务器只需要一次握手，就可以建立持久连接，并且支持双向通信
最大特点：服务器可以向客户端主动推送信息

```js
let ws = new WebSocket("ws://localhost:9999");
// 在客户端与服务端建立连接后触发
ws.onopen = function () {
	console.log("Connection open.");
	ws.send("hello");
};
// 在服务端给客户端发来消息的时候触发
ws.onmessage = function (res) {
	console.log(res); // 打印的是MessageEvent对象
	console.log(res.data); // 打印的是收到的消息
};
// 在客户端与服务端建立关闭后触发
ws.onclose = function (evt) {
	console.log("Connection closed.");
};
```

特点：

没有同源限制、数据格式轻量、可以发送二进制数据

# 30. 即时通讯：短轮询、长轮询、SSE(长连接)、websocket 的区别

短轮询：客户端每隔一段时间向服务器发一次请求，无论数据是否有更新，服务器都直接响应
长轮询：客户端向服务器发一个设置了较长网络超时时间的请求，服务器不会直接响应，数据有更新才响应，数据没更新会等到超时之后才返回
SSE：客户端和服务器之间用于传输数据的连接不会关闭，多个请求可以复用同一个 tcp 连接
websocket：客户端和服务器进行自由的实时双向通信
