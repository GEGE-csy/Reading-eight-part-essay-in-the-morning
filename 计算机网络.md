# http协议

## 1. get和post的区别

1. get请求是幂等的，对服务器资源不会产生影响。post请求不是

2. 浏览器一般会缓存get请求。post请求不会

3. post请求在浏览器回退时会再次提交。get请求不会

4. get请求通过url传参，post请求参数放在请求体中

5. get请求的参数有长度限制，类型必须是ASCII字符。post请求没有长度限制

## 2. put和post的区别

- put请求是幂等的，多次执行put请求会产生相同的结果。post请求不是

- put请求用于更新资源，每次请求都是对同一资源的操作。post请求用于提交数据，每次请求都会创建一个新资源。

## 3. 常见的http请求头和响应头 ⭕️

请求头：

- accept：浏览器支持的数据格式

- accept-charset：浏览器支持的字符集

- accept-encoding：浏览器支持的压缩编码

- cookie：当前页面设置的cookie

- host：发请求的页面所在的域

- user-agent：客户端代理的相关信息

响应头：

- date：发送响应的时间

- server：服务器信息

- cache-control：控制缓存

- content-type：服务器响应的数据格式

## 4. 常见的http请求方法

get：向服务器获取数据

post：向服务器提交数据

put：更新服务器资源

delete：删除服务器资源

options：跨域请求的预检查

## 5. http 常见状态码 ⭕️

五类：

- 1xx
  接受的请求正在处理
- 2xx
  请求正常处理
  (200，一切正常)
- 3xx
  重定向相关的状态码
  (301 永久重定向，请求的资源已经不在了，要用新 url 再访问)
  (302 临时重定向，请求的资源还在，但临时用另一个 url 访问)
  (304 请求的资源在浏览器有缓存，可以直接使用)
- 4xx
  客户端错误
  (400 请求报文有错误，参数有误，域名不存在)
  (403 服务器禁止访问资源)
  (404 请求的资源在服务器上不存在)
- 5xx
  服务器错误
  (500 服务器内部错误)
  (501 客户端请求的功能还不支持)
  (503 服务器正在维护无法处理请求)

## 6. 状态码304多好还是少好

客户端请求一些资源时，服务器会根据缓存内容判断资源是否变化

如果没变化就直接返回304，让客户端使用缓存

搜索引擎蜘蛛会更青睐内容更新频繁的网站，通过抓取网站返回的状态码来调节对网站的抓取频次，如果网站一直处于304，那蜘蛛可能会降低对网站的抓取频次

## 7. http1.0 和 http1.1 的区别

- http1.0 默认使用非持久连接，http1.1 默认使用持久连接，持久连接可以让多个http请求复用一个 tcp 连接，减少了tcp连接重复建立断开造成的额外开销
- http1.1 支持管道网络传输，只要第一个请求发出去了，不必等响应就可以发出第二个请求，可以减少整体的响应时间
- http1.0主要依赖expires和last-modified头来判断缓存，http1.1引入了更多缓存控制头，如cache-control、etag
- http1.1新增了host字段，一个服务器上可以托管多个域名，http1.0中认为每个服务器都绑定一个唯一的域名

http1.1 性能瓶颈：

- 不能压缩头部，头部信息越多延迟越大，只能压缩 body

- 队头堵塞问题：服务器要按照请求顺序处理请求，如果处理某一个请求耗时长，后续的请求处理都会被阻塞

- 请求只能由客户端发送，服务器只能被动响应

## 8. http1.1 和 http2.0 的区别 ⭕️

- 头部压缩
  
  请求头中的相同字段不发送

- 二进制协议
  
  http2的头信息和数据体都是二进制，http1中头信息必须是文本，数据体是文本/二进制

- 多路复用
  
  一个tcp连接中，客户端和服务器都可以同时发送请求或响应，且不用按顺序，解决了队头堵塞问题

- 服务器推送

   允许服务器主动向客户端发送资源

## 9. 说一下http3.0 ⭕️

http2 虽然通过多路复用，解决了 http 层的队头阻塞问题，
但是还存在 tcp 层的队头阻塞问题（一旦发生丢包，触发 tcp 的重传，所有 http 请求都会等待这个包重传回来）

http3 将 tcp 协议换成了 udp 协议，
采用基于 udp 协议的`quic协议`实现可靠性传输

- 不存在队头阻塞问题
  一个连接上并发传输多个数据流，一个流丢包了只会阻塞这个流，不会影响其他流
- 快速建立连接(快速握手)
- 流量控制、传输可靠等功能

## 10. http和https协议的区别

- https 要向 CA 申请数字证书，来安全传输公钥
- http 明文传输，存在安全风险。https 能解决 http 不安全的缺陷，使用 SSL/TLS 来加密数据包
- http 只需要经过 tcp 三次握手就可以进行 http 报文传输，但 https 经过 tcp 三次握手后还要经过 ssl/tls 握手，才能进行加密报文传输

## 11. 键入网址并且按下回车之后发生了什么？⭕️

1. 浏览器解析 url
   确定 web 服务器和文件名，生成 http 请求信息

2. 缓存判断
   
   判断请求的页面在缓存里有没有，有且没有失效就直接使用

3. dns 解析
   
   查询服务器域名对应的 ip 地址

4. 获取mac地址
   
   浏览器会根据自己的ip地址和子网掩码，判断服务器是否在同一网络里
   
   如果在同一网络里，使用ARP协议获取到目标的mac地址
   
   如果不在同一网络中，浏览器将请求发送给路由器，路由器会代为转发，此时同样可以使用ARP协议获取到目标的mac地址

5. TCP三次握手
   
   - 客户端向服务器发送一个SYN报文和一个随机序号，请求连接。
   
   - 服务器收到后会返回个SYN+ACK报文和一个新的随机序号，同时将客户端的序号+1作为确认应答号，确认请求连接。
   
   - 客户端收到服务器的确认应答后，会发送一个ACK报文，同时将服务端的序号+1作为确认应答号，客户端进入连接建立状态，服务端收到之后也进入连接建立状态

6. ssl/tls握手
   
   如果使用的是https协议，还存在一个ssl/tls握手过程
   
   - 客户端向服务器发送加密通信请求，请求中包含客户端使用的tls版本号、一个随机数和支持的加密方法。
   
   - 服务器收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。
   
   - 客户端检查数字证书是否有效，然后从数字证书获得服务器的公钥，加密一个新的随机数发给服务器。
   
   - 服务器收到后使用自己的私钥解密得到第三个随机数，这时候客户端和服务器都拥有三个随机数，按照约定好的加密方式，加密这三个随机数生成对话密钥，以后过程就用这个密钥来加密信息

7. 返回数据
   
   请求到达服务器，服务器会返回一个html文件作为响应

8. 页面渲染
   
   - 浏览器解析收到的html，构建DOM树。
   
   - 解析css，构建CSSOM树。
   
   - 如果遇到script标签，则阻塞。
   
   - 根据DOM树和CSSOM树构建渲染树。
   
   - 根据渲染树的信息，计算节点的大小和位置信息，形成布局。
   
   - 遍历渲染树的节点，调用节点的paint()绘制页面

9. TCP四次挥手
   
   - 客户端打算关闭连接，向服务器发送一个FIN报文，请求释放连接
   
   - 服务器收到后，会返回ACK报文，此时客户端到服务器的连接已经释放，但服务器依然可以向客户端发送数据
   
   - 完毕后服务器也向客户端发送一个FIN报文，请求释放连接
   
   - 客户端收到后，会返回ACK报文，进入TIME_WAIT状态，该状态会持续一段时间，如果期间没有服务器的重发请求，则进入关闭状态
   
   - 服务器收到客户端的ACK报文后，就进入关闭状态

## 12. 对keep-alive的理解 ⭕️

http协议采用的是请求-应答模式，每次请求/应答，都要建立tcp连接，完成后断开连接，这就是短连接。如果使用keep-alive，可以让多个请求复用同一个tcp连接，这就是长连接。

http1.0使用长连接要手动配置connection:keep-alive。http1.1则默认是keep-alive

【补充】：上面的是http的keep-alive。tcp的keep-alive也叫tcp保活机制，当客户端和服务器一段时间没有交互时，会发送探测报文来检测对方是否还在线

## 13. 页面有多张图片时，http是怎样的加载表现

http1中，浏览器对一个域名下最大tcp连接数为6，所以会请求多次。可以采用多域名部署，将网站资源分布在不同的子域名下，就可以同时发送更多请求

http2中，可以一瞬间加载出很多资源，因为http2支持多路复用，一个tcp连接中可以并行发送多个请求

## 14. http请求报文的组成 ⭕️

请求报文由4部分组成：

1. 请求行
   
   请求方法、url、http协议版本

2. 请求头
   
   由键值对组成

3. 空行

4. 请求体
   
   post、put 请求携带的数据

## 15. http响应报文的组成

响应报文由4部分组成：

1. 响应行
   
   协议版本、状态码、状态短语

2. 响应头
   
   由键值对组成

3. 空行

4. 响应体
   
   服务器响应的数据

## 16. http协议的优点和缺点

优点：

简单快速、无连接、无状态、灵活【允许传输任意类型的数据对象】

缺点：

无状态、明文传输、不安全

## 17. url 有哪些组成部分

比如：https://juejin.cn:8080/post/6908327746473033741#heading-21

协议部分：`https:`，后面的`//`是分隔符
域名部分：`juejin.cn` 端口部分：`8080`，http 默认 80，https 默认 443（非必需）
虚拟目录部分（非必需）：域名后的第一个`/`到最后一个`/`。这里是`/post/` 

文件名部分（非必需）：域名后最后一个`/`到`?`，如果没有`?`，则到`#`，如果没有`#`，则到结束都是文件名。这里是`6908327746473033741` 

锚部分（非必需）：`#`开始到最后。这里是`heading-21` 

参数部分（非必需）：`?`开始到`#`之间都是参数部分

# https协议

## 1. 什么是https协议

超文本传输安全协议
在 http 的基础上引入了一个安全层，使用 SSL/TLS 来加密数据包
因为 http 协议明文传输信息，存在一些信息被窃听、篡改、冒充的风险，
SSL/TLS 可以提供身份验证、信息加密等功能

## 2. ssl/tls的工作原理 ⭕️

ssl/tls是安全传输层协议，介于tcp和http之间的一层安全协议

ssl/tls的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密

- 散列函数
  
  特点是单向不可逆，任何数据改变都会影响散列函数的结果，可以用于防止信息篡改，验证数据的完整性

- 对称加密
  
  双方使用同一个秘钥对数据进行加密和解密
  
  问题是如何保证秘钥传输的安全性

- 非对称加密
  
  一个公钥和一个私钥，私钥加密的数据只能用公钥解密，公钥加密的数据只能用私钥解密
  
  问题是非对称加密的过程很慢，每次通信都使用非对称加密会造成时间过长

ssl/tls的工作方式就是客户端使用非对称加密和服务器通信，验证身份并协商对话秘钥，使用对称加密进行通信

## 3. 中间人如何抓包

必须在 https 加密通信之前抓包

- 截取服务端发送给客户端的证书，完成验证拿到服务端公钥。然后把自己的中间人证书发给客户端，
  客户端会验证中间人证书拿到中间人公钥来加密通信密钥，中间人拿到通信密钥
- 然后中间人再伪装成客户端，利用服务端公钥加密通信密钥传给服务端
- 这样加密通信建立完成，中间人也拿到了通信密钥

上面很重要的一步是客户端的证书校验，CA 不会随便给一个中间人签发不属于它的域名证书，所以证书不会在客户端的操作系统上
就只能把中间人的证书导入到客户端的操作系统上

## 4. https如何保证安全的 ⭕️

https 采用混合加密的方式：对称加密+非对称加密
在通信建立前，采用非对称加密，生成一对公钥和私钥。服务器会将公钥传给客户端

但是这个公钥的传递可能会被其他人截获，所以为了安全地传输公钥，就需要 CA 颁发的数字证书作为身份证明

那如果中间人篡改了数字证书呢？所以需要一个技术：数字签名

数字签名：用CA的私钥加密摘要得到数字签名

摘要：CA自带的hash算法对证书内容进行hash得到摘要

数字证书的内容就是原始信息+数字签名

我们电脑里会有 CA 的数字证书，通过这个拿到 CA 的公钥

用 CA 的公钥解密数字证书的签名，得到CA创建的摘要

再用同样的hash算法加密原始信息得到另一个摘要

比较这两个摘要是否一样，就能知道有没有中间人篡改证书

# DNS协议

## 1. DNS协议是什么

DNS是将域名转换成ip地址的系统

客户端向DNS服务器发送域名查询请求，DNS服务器告知客户端服务器的ip地址

## 2. DNS完整的查询过程 ⭕️

www.baidu.com

根域名(.)

顶级域名(.com)

权威域名(baidu.com)

先在浏览器缓存中查找有无对应的ip地址，找到则直接返回

客户端发起一个DNS查询请求，给本地DNS服务器，在本地DNS服务器缓存中查找

本地DNS服务器向根域名服务器发请求，根域名服务器返回顶级域名服务器地址

本地DNS服务器向顶级域名服务器发请求，服务器查询缓存，找到则返回，没找到则返回下一级的权威域名服务器地址

本地DNS服务器向权威域名服务器发请求，服务器返回结果

本地DNS服务器将结果缓存，返回给浏览器

# 网络模型

## 1. OSI七层模型 ⭕️

应用层：给用户提供应用服务

表示层：处理数据格式

会话层：建立、管理、终止会话

传输层：确保端对端的数据传输

网络层：实现数据包的路由选择和转发

数据链路层：提供可靠的数据传输

物理层：传输比特流

## 2. TCP/IP五层协议

应用层

传输层：有两个传输协议，TCP 和 UDP

网络层

数据链路层

物理层

# TCP和UDP

## 1. TCP和UDP的特点⭕️

TCP是传输控制协议，是面向连接的、可靠的流协议

- 面向连接
  
  发送数据前两端必须建立连接，建立连接的方法是三次握手

- 仅支持单播传输
  
  一个tcp连接只有两个端点，不支持多播和广播传输

- 面向字节流
  
  不保留报文边界的情况下以字节流进行传输

- 可靠传输
  
  每个包有序号，接收端对成功收到的包会发回确认，如果发送端在合理的往返时延内没收到确认，则数据重传

- 拥塞控制和流量控制

UDP是用户数据报协议，是无连接的、不可靠的协议

- 面向无连接
  
  不需要建立连接，可以直接发送数据

- 支持单播、多播、广播传输

- 面向报文
  
  保留报文的边界，一个一个报文独立传输

- 不可靠传输
  
  收到什么数据就传输什么数据，发送端也不关心对方是否接收了数据

- 头部开销小，传输报文更高效

## 2. TCP和UDP的区别

- 连接
  TCP 是面向连接的，发送数据之前两端必须建立连接
  UDP 是面向无连接的，即刻传送数据

- 传输对象
  TCP 只支持单播传输，一个连接只有两个端点，不支持多播和广播传输
  UDP 支持单播、多播、广播传输（一对一、一对多、多对多）

- 传输方式
  TCP 面向字节流传输
  UDP 面向报文传输，一个个报文独立传输

- 可靠性
  TCP 是可靠传输，数据可以无差错、不丢失、按序到达
  UDP 是不可靠传输

- 拥塞控制和流量控制
  TCP 有拥塞控制和流量控制的机制，来保证数据运输的安全性
  UDP 没有，即使网络拥堵也不会影响 UDP 的发送速率

- 使用场景
  TCP：效率要求相对低，准确性要求相对高。比如文件传输
  UDP：效率要求相对高，准确性要求相对低。比如视频聊天

## 3. TCP和UDP的应用场景

TCP：效率要求低，准确性要求高，比如文件传输

UDP：效率要求高，准确定要求低，比如即时通讯

## 4. TCP 的重传机制

TCP 在传输数据的时候可能出现数据包丢失的情况，针对这种情况，会采用重传机制解决

超时重传：
发送数据时，开启一个定时器，超过指定时间后，如果没有收到对方的确认应答，就会重新发送数据
（数据包丢失/确认应答丢失时都会）

## 5. TCP 的拥塞控制机制 ⭕️

拥塞控制是为了避免发送方的数据填满网络，当网络拥堵 时，如果继续发送大量数据包，可能导致数据包丢失，这时候 tcp 会重传数据，但是重传会加重网络负担，导致更多丢包

四种机制：

- 慢开始
  
  开始时将拥塞窗口设置为1，为了防止拥塞窗口过大设置一个慢开始门限，拥塞窗口小于慢开始门限时才使用慢开始算法，拥塞窗口大于慢开始门限时使用拥塞避免算法

- 拥塞避免 
  
  缓慢增加拥塞窗口大小。在慢开始和拥塞避免阶段，一旦发送方判断网络拥堵，就将慢开始门限设置为出现拥塞时发送窗口大小的一半，并将拥塞窗口设为1，然后执行慢开始算法

- 快速重传 
  
  接收方受到序号不对的报文会立刻发出重复确认，发送方收到三个重复确认就立即重传

- 快速恢复 
  
  如果收到三个重复确认，就将拥塞窗口大小减半，继续执行拥塞避免机制

## 6. TCP 的流量控制机制

流量控制是为了让发送方的发送速率不要太快，要让接收方来得及接收
具体表现在控制发送方的发送窗口大小，窗口大小就是每次传输数据的大小
发送方窗口大小根据接收方窗口大小来决定
发送方接收到接收方的确认报文后，会根据报文中接收方的窗口大小，来调整当前的发送窗口大小
当发送方收到一个零窗口时，必须停止发送数据，直到接收方重新发送一个不为零的窗口大小

## 7. TCP的可靠传输机制 ⭕️

1. 字节流传输
   
   tcp将数据分成以字节为单位的报文段，每个报文段都有自己的序号

2. 重传机制
   
   接收端收到报文段后都会发送ACK报文给发送端作为确认应答，如果发送方没有收到确认应答，则会重新传送该报文

3. 滑动窗口机制
   
   通过滑动窗口实现拥塞控制和流量控制，限制发送方窗口大小，防止发送过快接收方来不及接收，同时根据网络堵塞情况动态调整窗口大小

## 8. TCP的三次握手和四次挥手

三次握手：

- 客户端向服务端发送SYN报文和一个随机序号，请求连接

- 服务端收到后返回SYN+ACK报文和一个新的随机序号，同时将客户端的序号+1作为确认应答号，确认请求连接

- 客户端收到后返回ACK报文，同时将服务端的序号+1作为确认应答号，客户端进入连接建立状态，服务端收到后也进入连接建立状态

四次握手：

- 客户端向服务端发送FIN报文和一个随机序号，请求释放连接

- 服务端收到后返回ACK报文和一个新的随机序号，同时将客户端的序号+1作为确认应答号，确认释放连接。此时客户端到服务端的连接已经释放，但服务端仍然可以向客户端发送数据

- 服务端发送数据完毕后，也向客户端发送FIN报文和一个随机序号，请求释放连接

- 客户端收到后返回ACK报文和一个新的随机序号，同时将服务端的序号+1作为确认应答号，客户端进入TIME_WAIT状态，这个状态会持续一段时间，如果这段时间客户端没有收到服务器的重发请求，则进入关闭状态

- 服务端收到客户端的ACK报文后，就进入关闭状态

## 9. 为什么是三次握手，不是两次？

1. 同步双方初始序号，如果只有两次握手没办法确认服务端的序号被对方成功接收

2. 失效的请求连接报文段如果被服务端接收，服务端直接发出确认应答，就算建立了连接，但是客户端会忽略服务端的应答，服务端会一直等待客户端的数据

## 10. TCP 粘包？怎么处理

信息在传输的时候可能会被分成多个 TCP 报文，
如果两条消息的某部分内容被分到同一个 TCP 报文，就是 TCP 粘包问题，
接收方不知道消息的边界，就无法分出有效的信息

解决方法：在两个信息之间插入特殊字符作为边界

## 11. 为什么 udp 不会粘包？

udp 是面向报文传输的，一次发送一个报文，会保留报文的边界，接收方就能够区分

# websocket

## 1. 对websocket的理解

websocket是双向通信协议

浏览器和服务器只需要一次握手，就可以建立持久连接，并进行双向数据传递

最大的特点：服务器可以向客户端主动推送消息

特点：低时延、数据轻量、没有同源限制

## 2. 即时通讯的实现：短轮询、长轮询、SSE和websocket的区别

短轮询：客户端每隔一段时间向服务器发送请求，无论数据有无更新，服务器直接返回响应

长轮询：客户端向服务器发送请求，服务器不会直接响应，数据有更新才响应，否则会等待一段时间才返回

SSE(长连接)：客户端和服务器之间用于传输数据的连接不会关闭，多个请求可以复用同一个 tcp 连接

websocket：客户端和服务器进行自由的实时双向通信
