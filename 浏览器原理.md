# 浏览器安全

## 1. XSS攻击 ⭕️

XSS攻击指的是跨站脚本攻击

攻击者通过植入恶意脚本来获取敏感信息，破坏网页结构

XSS攻击一般分为：

- 存储型
  攻击者将恶意代码提交到了网站的数据库中，当用户访问这个网站，服务器从数据库中取出恶意代码并拼接到响应内容中返回给了用户
- 反射型
  攻击者诱导用户访问一个带有恶意代码的 url 后，用户通过url发起请求，网站收到请求后将恶意代码从 url 中取出并拼接到响应内容中，返回给浏览器
- DOM型

   攻击者通过修改网页的DOM结构，注入恶意代码

DOM型XSS取出和执行恶意代码都在客户端完成而不是服务端

攻击者可以通过XSS攻击进行以下操作：

- 窃取用户信息，如 cookie

- 篡改网页内容

## 2. 如何抵御 XSS 攻击 ⭕️

1. 对输入内容进行验证，过滤掉潜在的恶意内容。比如注入脚本、html标签、sql
2. 对需要显示在网页上的用户数据进行充分转义
3. 使用 CSP 安全策略，本质上是建一个白名单，限制页面可以加载的资源
4. 保护敏感信息，比如 cookie 设置 http-only，防止脚本读取 cookie

## 什么是CSP

CSP：内容安全策略。本质上是建立一个白名单，告诉浏览器哪些外部资源可以加载

两种方法开启CSP：

1. 设置http首部的`Content-Security-Policy`

2. 设置meta标签`<meta http-equiv="Content-Security-Policy">`

## 3. csrf 攻击

csrf攻击指的是跨站请求伪造

攻击者盗取用户身份，来执行未授权的请求

用户访问信任网站，登录成功后在浏览器存了 cookie，没有登出的情况下访问了另一个危险网站，危险网站中有恶意代码，比如发送一个恶意请求，就会携带浏览器存的 cookie 发送恶意请求，原来的网站就会认为是合法请求，以此实现冒充用户

## 4. 如何抵御 csrf 攻击 ⭕️

1. 验证请求来源，在服务器端检查请求头中的origin或referer字段

2. 使用csrf token，为用户生成一个唯一的csrf token，提交请求时验证

3. 启用cookie的samesite属性，限制cookie在跨站请求中的发送

## 5. cookie的samesite属性

samesite属性有三种模式：

- Strict严格模式，cookie任何时候都不会作为第三方cookie

- Lax宽松模式，允许部分情况下cookie作为第三方cookie：
  
  a标签链接，get表单

- none，cookie都会被发送

【第三方cookie：不同于用户访问的网站的域名的服务器发来的cookie，比如访问www.example.com，这个网站嵌入了另一个网站的广告，广告服务器发送来的cookie就是第三方cookie】

## 什么是点击劫持？如何防范点击劫持？

点击劫持是一种视觉欺骗的攻击手段，攻击者将危险网站通过iframe嵌套在网页中，并将iframe设成透明的，在页面中透出一个按钮诱导用户点击

可以在http响应头中设置X-FRAME-OPTIONS来控制网页是否可以在iframe中显示

## SQL注入攻击？

SQL注入攻击指的是攻击者在http请求中注入恶意的sql代码，服务器使用参数构建sql命令时，恶意sql被一起构造，在数据库中执行

## 6. 网络劫持

网络劫持：

1. DNS 劫持
   比如输入京东被强制跳转到淘宝
   攻击者会将目标域名重定向到错误的 ip 地址

2. HTTP 劫持
   比如访问谷歌但是一直有一些游戏的广告
   http 明文传输，攻击者在网络中截获http请求并篡改内容
   
   解决：使用https

## 7. 有哪些可能引起前端安全的问题

- 跨站脚本攻击XSS：攻击者注入恶意脚本来窃取用户信息、篡改网页内容

- 跨站请求伪造csrf：攻击者盗取用户身份，来执行未授权的请求

- 点击劫持，攻击者将一个透明的iframe覆盖网页内容，诱导用户点击

- 不安全的第三方库或插件：可能存在漏洞或植入恶意代码

# 进程和线程

## 1. 进程和线程的区别

【一个进程就是一段执行的程序，一个进程中执行的每个任务就是线程】

- 进程是 cpu 资源分配的最小单位，线程是 cpu 调度的最小单位，一个进程可以有多个线程

- 进程之间通信需要借助额外的机制，线程之间直接共享同一进程的资源

- 进程的创建、销毁、切换的开销都远大于线程

## 2. 进程间的通信方式

- 管道通信：单向通信机制，一个进程写一个进程读

- 消息队列通信：进程可以向队列发送消息、读取信息

- 信号量通信：解决多个进程对共享资源的访问

- 共享内存通信：多个进程可以访问同一块内存空间

## 3. chrome 的架构

包括：
1 个浏览器主进程：负责显示页面、用户交互、管理子进程
1 个 GPU 进程：负责绘制 UI 界面
1 个网络进程：负责加载网络资源
多个渲染进程：负责将 html、css、js 转换为网页
多个插件进程：负责插件的运行

打开一个网页最少需要 4 个进程：浏览器主进程、GPU 进程、网络进程、渲染进程（插件进程可不要）

## 4. 浏览器的渲染进程有哪些线程

- GUI 渲染线程：负责渲染页面

- JS 引擎线程：负责处理 js 脚本

- 事件处理线程：控制事件循环

- 定时器触发线程：setInterval 和 setTimeout 所在线程，定时器触发线程来计时，计时完后将定时器中的任务添加到任务队列

- http 请求线程：处理异步请求

GUI 渲染线程和 JS 引擎线程是互斥的，如果脚本执行时间过长，会造成页面渲染阻塞

## 5. 死锁产生的原因，如何解决死锁 ⭕️

多个进程争夺资源造成的僵局

产生死锁的原因：

- 竞争不可剥夺的资源（系统分配之后不能强行收回）
- 进程的推进顺序不正常（系统处于不安全状态的时候再向前推进，可能发生死锁）

产生死锁的必要条件：

- 互斥：一个资源一次只能被一个进程使用

- 请求和保持：进程因为请求资源而堵塞时，不释放已获得的资源

- 不剥夺：进程未使用完资源，不能剥夺，只能自己释放

- 循环等待：进程之间存在循环等待资源关系

预防死锁：

- 一次性分配所有资源

- 只要有一个资源得不到分配，就不给这个进程分配其他资源

- 进程获得了部分资源，但得不到其他资源，则释放已占有的资源

## 5. 如何实现浏览器内多个标签页的通信

标签页之间没办法直接通信，因此可以找一个中介者，让标签页和中介者进行通信

- 使用 websocket 协议，标签页向服务器发送数据，服务器向其他标签页推送数据
- 使用 localStorage，在一个标签页中监听 localStorage 的变化，另一个标签页修改数据的时候就可以监听到
- 使用 postMessage，一个页面监听 message 事件接收信息，一个页面使用 postMessage()方法发送信息

## 6. 对 service worker 的理解

service worker 是运行在浏览器背后的独立线程，
一般可以用来实现缓存功能
使用 service worker 传输协议必须是 https，涉及请求拦截，必须 https 保障安全

实现缓存功能：

1. 先注册 service worker
2. 监听 install 事件，缓存需要的文件
3. 拦截请求事件，之后用户访问就可以查询是否有缓存，没有再去请求

# 浏览器缓存

## 1. 浏览器缓存机制 ⭕️

强缓存和协商缓存

强缓存：只要缓存没有过期，就直接使用缓存资源，不用向服务器发起请求

强缓存可以通过响应头中的Expires(绝对时间)和Cache-Control(相对时间)来设置

Expires和Cache-Control一起设置时，Cache-Control优先级更高

浏览器第一次请求服务器资源，服务器返回资源时会在响应头添加Expires属性，来指定资源过期的时间，浏览器再次请求服务器资源时，会先计算资源是否过期，没有则使用缓存。Expires指定的是服务器的一个绝对时间，可能存在客户端和服务端的时间不一致的问题，就会影响缓存命中的结果。

因此http1.1提出了Cache-Control，指定的是一个相对时间，并提供了很多字段来更精确控制缓存

协商缓存：如果强缓存没有命中，则会使用协商缓存，会向服务器发起请求询问缓存是否可用

协商缓存通过两种头部实现：

- 请求头中的If-Modified-Since和响应头中的Last-Modified
  
  服务器返回资源时会在响应头加上Last-Modified，表示资源在服务器上最后修改的时间
  
  浏览器再次请求资源时会在请求头加上If-Modified-Since，值就是上一次的Last-Modified的值
  
  服务器比较If-Modified-Since和资源最后修改的时间，判断资源是否有变化，变化了就返回新的资源，没变化就返回304让浏览器读取本地资源

- 请求头中的If-None-Match和响应头中的Etag
  
  如果服务器1s修改资源两次，Last-Modified也只会有一个值，可能会造成缓存命中不准确
  
  Etag是根据资源生成的一个唯一标识，具体流程和上面一样，但Etag会更准确

Last-Modified和Etag同时存在时，Etag优先级更高

如果服务器要考虑负载均衡，每个服务器上Etag都不一样，那就最好不要设置Etag

工作流程：

浏览器第一次发请求，缓存了服务器返回的资源和响应头

浏览器再次发请求 

=> 有本地缓存 => 判断 Cache-Control 是否过期

               未过期 => 直接使用本地缓存

               过期 => 判断是否有 ETag

                      是 => 带 If-None-Match 请求

                      否 => 判断是否有Last-Modified

                            是 => 带If-Modified-Since 请求

                            否 => 直接向服务器请求

           

# 浏览器组成

## 1. 说下你对浏览器的理解

浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中

简单来说 浏览器可以分为两部分：shell和内核

shell指浏览器的外壳：例如菜单、工具栏，主要提供给用户界面操作，它是调用内核来实现各种功能的

内核是浏览器的核心，负责解析和渲染网页的内容

## 2. 浏览器内核

一般浏览器内核就是渲染引擎，负责解析和渲染网页的内容
也可以分成两部分：渲染引擎和 js 引擎
一开始渲染引擎和 js 引擎区分不明确，后来 js 引擎越来越独立，内核就倾向于只指渲染引擎

safari：webkit
chrome：以前 webkit 现在 blink
ie：trident

# 浏览器渲染原理

## 1. 浏览器的渲染过程

1. 浏览器解析收到的html，构建 DOM 树，DOM树表示网页的结构和内容
2. 浏览器解析 CSS，构建 CSSOM 规则树，CSSOM树表示网页的样式信息
3. 浏览器根据 DOM 树和 CSSOM 规则树构建渲染树，渲染树只包含需要显示的节点，渲染树的节点是渲染对象，渲染对象包含了颜色大小等属性
4. 浏览器根据渲染树的信息，计算节点的大小和位置信息，形成布局【也称为回流】
5. 浏览器遍历渲染树，调用渲染对象的 paint 方法将每个节点绘制到屏幕上
6. 浏览器将绘制好的图像传输给显示设备，显示在用户屏幕上

注意⚠️：为了更好的体验，浏览器的渲染引擎会采用渐进式渲染，也就是会尽快将内容呈现在屏幕上，并不是会等整个html都解析完再去构建渲染树

## 2. 浏览器渲染优化 ⭕️

1. 针对 javascript
   
   - 把 js 文件放在 body 后
   
   - 使用 async/defer 来异步加载 script

2. 针对 css
   
   - 导入外部样式可以用 link/@import，link 会在页面载入时同时加载，@import 会在页面载入后继续加载，优先用 link
   
   - 如果css少，尽量使用内嵌css

3. 针对DOM树和CSSOM树
   
   - html的层级不要太深
   
   - 减少css选择器的层级

4. 减少重排和重绘
   
   - 避免直接操作样式，最好通过类名批量修改样式
   
   - 如果频繁操作DOM，可以创建一个文档片段，在它上面进行一系列操作，再将整个文档片段插入到DOM中
   
   - 避免频繁读取布局信息，比如获取元素的尺寸位置，会触发回流
   
   - 使用css的transform属性替代定位属性，不会触发回流

## 3. 为什么我们一般把script放body后？

1. html解析时遇到js会停下来去加载js，script放body后避免在中间阻塞html解析

2. 如果js中有操作dom的代码，dom树生成一半又操作了dom，会导致dom树重新生成，引起回流和重绘

## 4. 为什么我们一般把css放head里？

确保在页面内容加载之前就开始加载和解析css样式，这样浏览器可以在渲染页面之前获得样式信息，如果放在body中的某个位置，页面可能会以没有样式的情况下显示，然后再重新渲染，这可能会造成短暂的页面闪烁。

## 5. 什么是文档的预解析？

预先加载外部的资源，比如外部脚本、样式表、图片

预解析不改变DOM树，只解析外部资源的引用

## 6. 什么情况会阻塞渲染？

- js阻塞渲染，遇到js代码会暂停html解析【阻塞html解析从而阻塞dom解析从而阻塞dom渲染】【dom解析=构建dom树，dom渲染=将dom树转成页面】

- css加载阻塞渲染
  
  渲染树依赖于dom树和cssom树，必须等到cssom树构建完也就是css加载完才能开始渲染

## 7. js阻塞dom树的解析和渲染，css不阻塞解析阻塞渲染

1. js阻塞dom树的解析和渲染

2. css加载不阻塞dom树解析，阻塞dom树渲染
   
   【dom解析和css解析是并行的过程，css是不会阻塞dom解析的】

3. css加载会阻塞js执行
   
   【js可能会操作css样式，所以css会在js执行前先加载完毕】

[css加载会造成阻塞吗？ - 掘金](https://juejin.cn/post/6844903667733118983)

## 8. 如何优化关键渲染路径 ⭕️

关键渲染路径：浏览器将html、css、js转换成屏幕上的像素所经历的步骤

包括了文档解析、样式计算、构建渲染树、布局和绘制等过程

（浏览器的渲染过程）

考虑三个角度减小：

- 关键资源的数量：可能阻止页面首次渲染的资源（html、css、js）

- 关键路径长度：获取所有关键资源所需的总时间

- 关键字节的数量：加载关键资源的总字节数

优化CRP:

1. 通过异步/延迟加载/消除非关键资源来减少关键资源的请求数量
   
   【比如图片、广告等延迟加载、删除不必要的或未使用的资源请求】

2. 优化必须的请求数量和每个请求的文件体积
   
   【压缩资源、利用缓存优化】

3. 区分关键资源优先级来优化加载关键资源的顺序，缩短关键路径长度
   
   【通过link标签的rel属性来指定资源的优先级】
   
   `<link rel="preload" href="path/to/resource" as="type" importance="high">`
   
   - preload 建议浏览器尽早加载该资源
   
   - prefetch 建议浏览器在后台加载该资源，以备将来使用
   
   - prerender 建议浏览器预渲染该资源，

# 浏览器本地存储

## 1. 浏览器本地存储方式

- cookie：
  纯文本文件，大小 4k 左右，浏览器每次发请求都会携带 cookie
  会话级存储，可以设置过期时间
  不能跨域，只能同源页面共享
  
  使用场景：cookie 和 session 结合使用，把 sessionId 存在 cookie 中，每次请求携带 sessionId

- localStorage：
  大小 5m 左右
  持久存储，不主动清理就会一直存在
  不能跨域，只能同源页面共享

- sessionStorage：
  临时保存同一个窗口的数据
  关闭窗口后数据会消失
  不能跨域，只能同一窗口共享

## 简单谈一下cookie

cookie是服务器发送给浏览器的用于维护会话状态的数据，存储在浏览器的本地文件中。用户下一次访问同源网站时，就会在请求头携带cookie发送给服务器

服务端可以使用`Set-Cookie`响应头来配置cookie信息

## 2. cookie 有哪些字段，作用是什么

name、value、size、domain(可以访问此cookie的域名)、path(可以访问此cookie的页面路径)、expires(cookie的过期时间，具体时间点)
max-age(cookie的有效期，时间间隔)【优先级高于expires】、secure(是否只能在https协议下传输)、httponly(是否可以用脚本访问)

## cookie、localStorage、sessionStorage的区别

- 生命周期：
  
  cookie可以设置失效时间，不设置默认是关闭浏览器后失效
  
  localStorage永久存储
  
  sessionStorage关闭页面后被清除

- 存放数据大小：
  
  cookie 4kb，localStorage和sessionStorage 5mb

- http请求：
  
  cookie每次都会携带在http头中，localStorage和sessionStorage只在浏览器保存

## 3. 前端存储的方式有哪些（浏览器存储策略）

- cookie
  兼容性好、使用方便
  大小只有 4k、每个域名有数量限制
  发请求时会自动携带
- localStorage
  操作简单、能永久性存储
- sessionStorage
  会话级存储，关闭窗口就会清除数据
- indexedDB
  nosql 数据库，键值对存储
  存储空间大，不少于 250m

三者区别：

- cookie 是服务端写入，sessionStorage 和 localStorage 由前端写入
- cookie 的生命周期是服务端写入时就设置好的，localStorage 除非手动清除一直存在，sessionStorage 页面关闭自动清除

# 浏览器的同源策略

## 1. 什么是同源策略

跨域问题就是浏览器的同源策略造成的
同源指的是：协议、域名、端口号必须一致

限制了三方面：

- js不能跨域访问cookie、localStorage、indexedDB等存储性内容
- js不能跨域操作DOM节点
- ajax 不能发送跨域请求

## 2. 如何解决跨域问题 ⭕️

1. CORS 跨域资源共享
   
   - CORS是一种机制：服务器配置一些 http 响应头，来解除浏览器的跨域访问限制
   
   - CORS 分为简单请求和非简单请求：
     
     - 简单请求：浏览器发送请求会在请求头加一个 origin 字段，说明这次请求来自哪个源，服务器根据这个值，判断 origin 指定的源在不在允许范围内，然后返回响应。
       浏览器根据响应头有没有 Access-Control-Allow-Origin 字段来判断是否成功
     
     - 非简单请求：在通信之前会先发一个预检请求，请求方法是 options
       携带 origin、Access-Control-Request-Method、Access-Control-Request-Headers服务器根据这三个字段判断是否允许跨域请求。
       浏览器根据响应头有没有 Access-Control-Allow-Origin 字段来判断是否成功，预检请求的响应成功了才会发送正式请求
   
   - 简单请求：
     
     - 1.请求方法为get、head、post 
     
     - 2.请求头字段只包含：accept、accept-language、content-language、content-type（仅限于 application/x-www-form-urlencoded、multipart/form-data、text/plain 之一）

【跨域请求默认不带 cookie，如果想要带要设置 withCredentials】

2. jsonp
   利用 script 标签没有跨域限制，通过 src 属性发送带 callback 参数的 get 请求。服务端调用 callback 将数据作为参数返回

   只支持 get、不安全，可能受到xss攻击

3. postMessage
   窗口之间的跨域通信
   
   postMessage()和window.addEventListener('message', )

4. nginx 反向代理
   配置一个代理服务器，域名和 domain1 一样，通过这个服务器帮我们访问 domain2，服务器之间不存在跨域

5. websocket
   本身就支持跨域

## 3. 正向代理和反向代理的区别

正：隐藏真实的客户端，客户端要发送的请求由代理服务器代发
反：隐藏真实的服务端，代理服务器收到请求后再转发到目标服务器上

# 浏览器的事件机制

## 1. 同步和异步

一个进程执行某个请求，这个请求需要等待一段时间才能返回，进程会一直等待还是执行其他请求

## 2. 对事件循环的理解

代码开始执行时，会创建一个全局执行上下文，并推入主线程的执行栈中，然后开始执行同步代码。如果执行同步代码的时候遇到异步事件，会将这个事件挂起，继续执行其他同步代码。当异步事件执行完毕后，再将异步事件对应的回调加入到任务队列中等待执行。执行栈中的代码执行完之后就会去任务队列读取任务压入栈中执行
任务队列分为宏任务队列和微任务队列，执行完一个宏任务就会检查微任务队列是否为空，不为空就一次性执行完所有微任务，
下一次循环再取第一个宏任务执行

具体：先从整块代码开始第一次执行，同步代码(属于宏任务) => 所有微任务 => 下一个宏任务

【视图渲染发生在本轮的微任务队列被执行完之后】

## 3. 宏任务和微任务

宏任务：同步代码、setTimeout、setInterval、dom渲染
微任务：promise 的 then()、await 语句后、node 中的process.nextTick、

## 单线程的 JavaScript 是怎么实现异步的?

单线程的 JavaScript 实现异步的核心机制是事件循环

js中异步任务通常通过promise、async/await实现。遇到异步任务的时候，js会将任务放入任务队列，等待主线程空闲了再执行

## 4. 什么是执行栈

执行栈：用来管理执行上下文的
js 执行代码，遇到全局代码会创建全局执行上下文，压入执行上下文栈
每遇到一个函数调用，就创建一个函数执行上下文，压入栈，函数执行完之后，就会从栈中弹出
继续执行下一个执行上下文
所有代码执行完之后，从栈中弹出全局执行上下文

## 5. node 中的事件循环

分 6 个阶段，进入某一个阶段的时候，都会从对应的回调队列中取出函数执行
队列为空才进入下个阶段

- timers 阶段
  执行 setTimeout 和 setInterval 回调，
  如果回调中触发了微任务，执行完所有回调之后再执行微任务
- pending callbacks
  执行上一轮事件循环遗留的 I/O 回调
- idle/prepare
  给系统内部使用
- poll 轮询阶段
  对应的回调队列不为空的时候，就执行回调，如果回调触发了微任务，会在每个回调执行完之后执行对应的微任务，而不是等所有回调都执行完才执行
  对应的回调队列为空的时候，如果有计时器没执行，就会结束轮询进入 check 阶段。否则会阻塞并等待正在执行的 I/O 操作完成
- check 阶段
  执行 setImmediate 回调，
  如果回调中触发了微任务，执行完所有回调之后再执行微任务
- close callbacks
  执行一些关闭回调

还有一个 process.nextTick，独立于事件循环之外
有一个自己的队列，每个阶段完成后，会清空 nextTick 队列，并且是**比微任务优先清空的*

# 性能优化

## 前端性能优化指标，你做过哪些性能优化

## 有一个web页面，性能较差，你会从什么角度分析和提升性能

前端性能优化指标大概分为三类：

- lcp最大内容绘制，代表了页面的速度指标

- fid首次输入延迟，代表了页面的交互体验指标

- cls页面排版是否稳定，代表了页面的稳定指标

【fcp首次内容绘制：用户访问 -> 页面内容任何部分渲染完成的时间，文本或图片或xxx】

【fp首次绘制：首次绘制**像素**的时间，不需要内容是有意义的】

【lcp最大内容绘制：从用户访问 -> 可视区域内最大图像或者文本渲染完成的时间】

对于前端应用来说，网络耗时、页面加载耗时、脚本执行耗时、渲染耗时等耗时情况会影响用户等待时长，而cpu占用、内存占用、本地缓存占用等可能会导致页面卡顿甚至卡死

所以性能优化可以分别从耗时和资源占用两个方面来解决：

时间角度优化：

- 网络请求优化：静态资源部署cdn、接口缓存减少重复请求

- 资源大小优化：对资源进行压缩合并，选择合适的图片格式，小图用base64

- 首屏加载优化：懒加载首屏非必要资源、预先加载首屏关键资源、代码分割

- 渲染过程的优化：减少直接操作dom和样式计算防止回流重绘

空间角度优化：

- 合理使用缓存，及时进行缓存清理

- 避免内存泄漏，及时解除引用

- 从代码角度优化，减少不必要的计算，避免复杂的递归调用，降低cpu占用率

# 设计模式

设计模式：是一种代码编写的模式

常见的设计模式以及使用场景：

- 单例模式：
  
  一个类只有一个实例，并提供一个全局访问点
  
  使用场景：vuex中的store、页面的弹窗

- 观察者模式：
  
  对象间的一种一对多的依赖关系，当一个对象状态发生变化，所有依赖它的对象都会得到通知并自动更新
  
  使用场景：用户收藏商品后价格变化通知用户

- 发布-订阅模式：
  
  解耦后的观察者模式，发布者和订阅者不知道彼此的存在，通过调度中心来维持发布者和订阅者的联系
  
  使用场景：vue中双向数据绑定

- 工厂模式：
  
  用来创建对象的一种设计模式，不暴露创建对象的具体逻辑，而将逻辑封装在一个函数中
  
  使用场景：vue异步组件
