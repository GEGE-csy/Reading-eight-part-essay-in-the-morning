# 1. XSS 攻击

跨站脚本攻击
攻击者在目标网站植入恶意脚本，恶意脚本在用户的浏览器上运行，从而盗取用户的信息

攻击类型：

- 存储型
  恶意脚本存储在目标服务器上，浏览器请求数据，脚本从服务器传回并执行
- 反射型
  攻击者诱导用户访问一个带有恶意代码的 url 后，服务器将恶意代码返回给浏览器

存储型 XSS 的恶意代码存在数据库，反射型 XSS 的恶意代码存在 url
获取 cookie、恶意跳转

# 2.如何抵御 XSS 攻击

1. 拼接 html 的时候要进行充分转义
2. 设置 CSP 安全策略，本质上是建一个白名单，规定浏览器可以加载的资源
3. 保护敏感信息，比如 cookie 设置 http-only，防止脚本读取 cookie

# 3. csrf 攻击

跨站请求伪造攻击
攻击者盗用用户的身份，进行恶意请求

用户访问信任网站，登录成功后在浏览器存了 cookie，没有登出的情况下访问了另一个危险网站，
危险网站中有恶意代码，比如发送一个恶意请求，就会携带浏览器存的 cookie 发送恶意请求，
原来的网站就会认为是合法请求。

# 4. 如何抵御 csrf 攻击

添加 token 验证

# 5. 网络劫持

网络劫持：

1. DNS 劫持
   比如输入京东被强制跳转到淘宝
   会把目标域名解析到错误的 ip 地址
2. HTTP 劫持
   比如访问谷歌但是一直有一些游戏的广告
   http 明文传输，运营商可以修改 http 的响应内容(加广告)

# 6. 进程和线程

一个进程就是一段执行的程序，一个进程中执行的每个任务就是线程

进程是资源分配的最小单位，线程是 cpu 调度的最小单位
一个线程只属于一个进程，但是一个进程可以包含多个线程
进程的创建、销毁、切换的开销都远大于线程

# 7.进程间的通信方式

- 管道通信
  一段缓冲区，进程 1 可以把需要交互的数据拷贝到这里，进程 2 就可以读取
- 消息队列通信
  进程把消息放进消息队列，另一个进程需要的时候去读取
- 共享内存通信
  多个进程可以访问同一块内存空间

# 8. chrome 的架构

包括：
1 个浏览器主进程：负责显示页面、用户交互、管理子进程
1 个 GPU 进程：负责绘制 UI 界面
1 个网络进程：负责加载网络资源
多个渲染进程：负责将 html、css、js 转换为网页
多个插件进程：负责插件的运行

打开一个网页最少需要 4 个进程：浏览器主进程、GPU 进程、网络进程、渲染进程（插件进程可不要）

# 9.浏览器的渲染进程有哪些线程

GUI 渲染线程：负责渲染页面
JS 引擎线程：负责处理了 js 脚本
事件触发线程：控制事件循环
定时器触发线程：setInterval 和 setTimeout 所在线程，定时器触发线程来计时，计时完后将定时器中的任务添加到任务队列
异步 http 请求线程：处理异步请求

GUI 渲染线程和 JS 引擎线程是互斥的，如果脚本执行时间过长，会造成页面渲染阻塞

# 10. 死锁产生的原因，如何解决死锁

多个进程争夺资源造成的僵局

产生死锁的原因：

- 竞争不可剥夺的资源（系统分配之后不能强行收回）
- 进程的推进顺序不正常（系统处于不安全状态的时候再向前推进，可能发生死锁）

产生死锁的必要条件：

互斥：一个资源一次只能被一个进程使用
请求和等待：进程因为请求资源而堵塞时，不释放已获得的资源
不剥夺：进程未使用完资源，不能剥夺，只能自己释放
循环等待：进程之间存在循环等待资源关系

预防死锁：
一次性分配所有资源
只要有一个资源得不到分配，就不给这个进程分配其他资源
进程获得了部分资源，但得不到其他资源，则释放已占有的资源

# 11. 如何实现浏览器内多个标签页的通信

标签页之间没办法直接通信，因此可以找一个中介者，让标签页和中介者进行通信

- 使用 websocket 协议，标签页向服务器发送数据，服务器向其他标签页推送数据
- 使用 localStorage，在一个标签页中监听 localStorage 的变化，另一个标签页修改数据的时候就可以监听到
- 使用 postMessage，一个页面监听 message 事件接收信息，一个页面使用 postMessage()方法发送信息

# 12. 对 service worker 的理解

service worker 是运行在浏览器背后的独立线程，
一般可以用来实现缓存功能
使用 service worker 传输协议必须是 https，涉及请求拦截，必须 https 保障安全

实现缓存功能：

1. 先注册 service worker
2. 监听 install 事件，缓存需要的文件
3. 拦截请求事件，之后用户访问就可以查询是否有缓存，没有再去请求

# 13. 浏览器内核

一般浏览器内核就是渲染引擎，负责解释语法并渲染网页
也可以分成两部分：渲染引擎和 js 引擎
一开始渲染引擎和 js 引擎区分不明确，后来 js 引擎越来越独立，内核就倾向于只指渲染引擎

safari：webkit
chrome：以前 webkit 现在 blink
ie：trident

# 14. 浏览器的渲染过程

1. 解析 html，生成 DOM 树(由 DOM 元素和属性节点组成)
2. 解析 CSS，生成 CSSOM 规则树
3. 根据 DOM 树和 CSSOM 规则树构建渲染树，渲染树的节点是渲染对象，包含了样式信息
4. 根据渲染树，计算节点的大小和位置信息
5. 调用渲染对象的 paint 方法绘制页面

# 15.浏览器渲染优化

- 针对 javascript
  js 会阻塞 html 和 css 的解析
  把 js 文件放在 body 后，使用 async/defer 属性来引入 script
- 针对 css
  导入外部样式可以用 link/@import，link 会在页面载入时同时加载，@import 会在页面载入后继续加载
  优先用 link
- 减少重排和重绘
  减少直接操作 dom 元素，该用类名控制
  先给元素设置 display:none，操作结束后再让它显示出来

# 16. 浏览器本地存储方式

- cookie：
  纯文本文件，大小 4k 左右，浏览器每次发请求都会携带 cookie
  会话级存储，可以设置过期时间
  不能跨域，不同域的 cookie 不能共享
  使用场景：cookie 和 session 结合使用，把 sessionId 存在 cookie 中，每次请求携带 sessionId
- localStorage：
  大小 5m 左右
  持久存储，不主动清理就会一直存在
  受同源策略限制，只能同源页面共享
- sessionStorage：
  保存同一个窗口的数据
  关闭窗口后数据会消失
  受同源策略限制，只能同一窗口共享

# 17. cookie 有哪些字段，作用是什么

name、value、size、domain(所属域名)、path(可以访问 cookie 的页面路径)
max-age(超时时间)、secure(是否使用 https 协议)、httponly(设置是否可以用脚本访问)

# 18. 前端存储的方式有哪些

- cookie
  兼容性好、使用方便
  大小只有 4k、每个域名有数量限制
  发请求时会自动携带
- localStorage
  操作简单、能永久性存储
- sessionStorage
  会话级存储，关闭窗口就会清除数据
- indexedDB
  nosql 数据库，键值对存储
  存储空间大，不少于 250m

localStorage 和 cookie 的区别

- 能保存的数据大小不同，cookie4k，localStorage5m
- 有效时间不同，cookie 可以自己设置有效时间，localStorage 只要不手动清理一直有效
- 请求时 cookie 会被自动携带，localStorage 不会

localStorage 和 sessionStorage 的区别
localStorage 是永久性存储，关闭浏览器也不会消失
sessionStorage 是会话级存储，关闭浏览器就会消失
localStorage 用于长期登录，sessionStorage 用于敏感账号一次性登录

# 19.浏览器的同源策略

跨域问题就是浏览器的同源策略造成的
同源：协议、域名、端口号必须一致

限制了：
当前域下的不能访问其他域下的

- cookie、localStorage、sessionStorage、indexedDB 等存储性内容
- DOM 节点
- ajax 请求不能发送

# 20.如何解决跨域问题

1. CORS 跨域资源共享
   CORS 分为简单请求和非简单请求：

   简单请求：浏览器发送会在请求头加一个 origin 字段，说明这次请求来自哪个源，服务器根据这个值
   来判断 origin 指定的源在不在允许范围内，然后返回响应
   浏览器根据响应头有没有 Access-Control-Allow-Origin 字段来判断是否成功

   非简单请求：在通信之前会先发一个预检请求，请求方法是 options
   携带 origin、Access-Control-Request-Method、Access-Control-Request-Headers
   服务器根据这三个字段判断是否允许跨域请求
   浏览器根据响应头有没有 Access-Control-Allow-Origin 字段来判断是否成功

跨域请求默认不带 cookie，如果想要带要设置 withCredentials

2. jsonp
   利用 script 标签没有跨域限制，通过 src 属性发送带 callback 参数的 get 请求，
   服务端调用 callback 将数据作为参数返回

只支持 get、不安全

3. postMessage
   窗口之间的信息传递
4. nginx 反向代理
   配置一个代理服务器，域名和 domain1 一样，通过这个服务器帮我们访问 domain2，服务器之间不存在跨域
5. websocket
   本身就支持跨域

# 21.正向代理和反向代理的区别

正：隐藏真实的客户端，客户端要发送的请求由代理服务器代发
反：隐藏真实的服务端，代理服务器收到请求后再转发到目标服务器上

# 22. 事件模型？

事件模型分为事件捕获和事件冒泡
捕获：事件从 window 对象往下向目标节点传播
冒泡：事件从目标节点往上向 window 对象传播

# 23. 同步和异步

一个进程执行某个请求，这个请求需要等待一段时间才能返回，进程会一直等待还是执行其他请求

# 24. 对事件循环的理解

代码执行时，会将任务压入执行栈中执行，同步任务会交给主线程执行，如果遇到了异步任务，会将异步任务加入任务队列
等主线程里的任务执行完了就去任务队列里读取异步任务执行。
任务队列分为宏任务队列和微任务队列，执行完一个宏任务就会检查微任务队列是否为空，不为空就一次性执行完所有微任务，
下一次循环再取第一个宏任务执行

具体：先从整块代码开始第一次执行，同步任务 => 所有微任务 => 下一个宏任务

# 25. 宏任务和微任务

宏任务：script 脚本、setTimeout、setInterval
微任务：promise 的 then()、await 语句后一句话、node 中的 process.nextTick、

# 26.什么是执行栈

执行栈是管理执行上下文的
执行代码的时候，全局代码会创建全局执行上下文并压入执行栈，
遇到一个函数调用，就创建一个函数执行上下文压入栈
函数执行完之后，函数执行上下文就会弹出栈
所有代码都执行完之后，栈中就会弹出全局执行上下文

# 26.node 中的事件循环

分 6 个阶段，进入某一个阶段的时候，都会从对应的回调队列中取出函数执行
队列为空才进入下个阶段

- timers 阶段
  执行 setTimeout 和 setInterval 回调，
  如果回调中触发了微任务，执行回调之后再执行微任务
- pending callbacks
  执行上一轮事件循环遗留的 I/O 回调
- idle/prepare
  给系统内部使用
- poll 轮询阶段
  对应的回调队列不为空的时候，就执行回调，回调触发了微任务，会在每个回调执行完之后执行对应的微任务
  对应的回调队列为空的时候，如果有计时器没执行，就会结束轮询进入 check 阶段。否则会阻塞然后等待 I/O 操作完成
- check 阶段
  执行 setImmediate 回调，
  如果回调中触发了微任务，执行回调之后再执行微任务
- close callbacks
  执行一些关闭回调

还有一个 process.nextTick，独立于事件循环之外
又一个自己的队列，每个阶段完成后，会清空 nextTick 队列，并且是比微任务优先清空的

# 27. 事件触发的过程

三个阶段：捕获阶段-目标阶段-冒泡阶段
从 window 向目标处传播-到达目标处触发事件-目标处往 window 传播
