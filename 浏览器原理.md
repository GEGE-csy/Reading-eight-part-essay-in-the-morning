# 浏览器安全

## 1. XSS攻击 ⭕️

XSS攻击指的是跨站脚本攻击

XSS攻击一般分为：

- 存储型
  攻击者将恶意代码提交到了网站的数据库中，当用户访问这个网站，服务器从数据库中取出恶意代码并拼接到响应内容中返回给了用户
- 反射型
  攻击者诱导用户访问一个带有恶意代码的 url 后，用户通过url发起请求，网站收到请求后将恶意代码从 url 中取出并拼接到响应内容中，返回给浏览器
- DOM型

   攻击者通过修改网页的DOM结构，注入恶意代码

DOM型XSS取出和执行恶意代码都在客户端完成而不是服务端

攻击者可以通过XSS攻击进行以下操作：

- 窃取用户信息，如 cookie

- 篡改网页内容

## 2. 如何抵御 XSS 攻击 ⭕️

1. 对输入内容进行验证，过滤掉潜在的恶意内容。比如注入脚本、html标签、sql
2. 对需要显示在网页上的用户数据进行充分转义
3. 使用 CSP 安全策略，本质上是建一个白名单，限制页面可以加载的资源
4. 保护敏感信息，比如 cookie 设置 http-only，防止脚本读取 cookie

## 3. csrf 攻击

csrf攻击指的是跨站请求伪造

用户访问信任网站，登录成功后在浏览器存了 cookie，没有登出的情况下访问了另一个危险网站，危险网站中有恶意代码，比如发送一个恶意请求，就会携带浏览器存的 cookie 发送恶意请求，原来的网站就会认为是合法请求，以此实现冒充用户

## 4. 如何抵御 csrf 攻击 ⭕️

1. 验证请求来源，在服务器端检查请求头中的origin或referer字段

2. 使用csrf token，为用户生成一个唯一的csrf token，提交请求时验证

3. 启用cookie的samesite属性，限制cookie在跨站请求中的发送

## 5. cookie的samesite属性

samesite属性有三种模式：

- Strict严格模式，只会在 从创建cookie的网站发起请求时 被发送

- Lax宽松模式，cookie会在一些情况下被发送：
  
  - 用户点击链接或url访问不同网站的时候，会发送
  
  - 网站嵌入了来自不同网站的资源，请求这些资源时也会发送
  
  【但不会发送跨域的ajax请求】

- none，cookie无条件被发送

## 6. 网络劫持

网络劫持：

1. DNS 劫持
   比如输入京东被强制跳转到淘宝
   攻击者会将目标域名重定向到错误的 ip 地址

2. HTTP 劫持
   比如访问谷歌但是一直有一些游戏的广告
   http 明文传输，攻击者在网络中截获http请求并篡改内容
   
   解决：使用https

## 7. 有哪些可能引起前端安全的问题

- 跨站脚本攻击XSS：攻击者注入恶意脚本来窃取用户信息、篡改网页内容

- 跨站请求伪造csrf：攻击者盗取用户身份，来执行未授权的请求

- 点击劫持，攻击者将一个透明的iframe覆盖网页内容，诱导用户点击

- 不安全的第三方库或插件：可能存在漏洞或植入恶意代码

# 进程和线程

## 1. 进程和线程的区别

【一个进程就是一段执行的程序，一个进程中执行的每个任务就是线程】

- 进程是 cpu 资源分配的最小单位，线程是 cpu 调度的最小单位，一个进程可以有多个线程

- 进程之间通信需要借助额外的机制，线程之间直接共享同一进程的资源

- 进程的创建、销毁、切换的开销都远大于线程

## 2. 进程间的通信方式

- 管道通信
  管道就是一段缓冲区，进程 1 可以把需要交互的数据拷贝到这里，进程 2 就可以读取
- 消息队列通信
  进程可以向队列发送消息来进行通信
- 信号量通信

   解决多竞争内存的问题

- 共享内存通信
  多个进程可以访问同一块内存空间

## 3. chrome 的架构

包括：
1 个浏览器主进程：负责显示页面、用户交互、管理子进程
1 个 GPU 进程：负责绘制 UI 界面
1 个网络进程：负责加载网络资源
多个渲染进程：负责将 html、css、js 转换为网页
多个插件进程：负责插件的运行

打开一个网页最少需要 4 个进程：浏览器主进程、GPU 进程、网络进程、渲染进程（插件进程可不要）

## 4. 浏览器的渲染进程有哪些线程

GUI 渲染线程：负责渲染页面
JS 引擎线程：负责处理 js 脚本
事件处理线程：控制事件循环
定时器触发线程：setInterval 和 setTimeout 所在线程，定时器触发线程来计时，计时完后将定时器中的任务添加到任务队列
http 请求线程：处理异步请求

GUI 渲染线程和 JS 引擎线程是互斥的，如果脚本执行时间过长，会造成页面渲染阻塞

## 5. 死锁产生的原因，如何解决死锁 ⭕️

多个进程争夺资源造成的僵局

产生死锁的原因：

- 竞争不可剥夺的资源（系统分配之后不能强行收回）
- 进程的推进顺序不正常（系统处于不安全状态的时候再向前推进，可能发生死锁）

产生死锁的必要条件：

- 互斥：一个资源一次只能被一个进程使用

- 请求和保持：进程因为请求资源而堵塞时，不释放已获得的资源

- 不剥夺：进程未使用完资源，不能剥夺，只能自己释放

- 循环等待：进程之间存在循环等待资源关系

预防死锁：

- 一次性分配所有资源

- 只要有一个资源得不到分配，就不给这个进程分配其他资源

- 进程获得了部分资源，但得不到其他资源，则释放已占有的资源

## 5. 如何实现浏览器内多个标签页的通信

标签页之间没办法直接通信，因此可以找一个中介者，让标签页和中介者进行通信

- 使用 websocket 协议，标签页向服务器发送数据，服务器向其他标签页推送数据
- 使用 localStorage，在一个标签页中监听 localStorage 的变化，另一个标签页修改数据的时候就可以监听到
- 使用 postMessage，一个页面监听 message 事件接收信息，一个页面使用 postMessage()方法发送信息

## 6. 对 service worker 的理解

service worker 是运行在浏览器背后的独立线程，
一般可以用来实现缓存功能
使用 service worker 传输协议必须是 https，涉及请求拦截，必须 https 保障安全

实现缓存功能：

1. 先注册 service worker
2. 监听 install 事件，缓存需要的文件
3. 拦截请求事件，之后用户访问就可以查询是否有缓存，没有再去请求

# 浏览器缓存

## 1. 浏览器缓存机制 ⭕️

强缓存和协商缓存



强缓存：只要缓存没有过期，就直接使用缓存资源，不用向服务器发起请求

强缓存可以通过响应头中的Expires(绝对时间)和Cache-Control(相对时间)来设置

Expires和Cache-Control一起设置时，Cache-Control优先级更高

浏览器第一次请求服务器资源，服务器返回资源时会在响应头添加Expires属性，来指定资源过期的时间，浏览器再次请求服务器资源时，会先计算资源是否过期，没有则使用缓存。Expires指定的是服务器的一个绝对时间，可能存在客户端和服务端的时间不一致的问题，就会影响缓存命中的结果。

因此http1.1提出了Cache-Control，指定的是一个相对时间，并提供了很多字段来更精确控制缓存



协商缓存：如果强缓存没有命中，则会使用协商缓存，会向服务器发起请求询问缓存是否可用

协商缓存通过两种头部实现：

- 请求头中的If-Modified-Since和响应头中的Last-Modified
  
  浏览器第一次请求资源，服务器返回资源时会在响应头加上Last-Modified，表示资源在服务器上最后修改的时间
  
  浏览器再次请求资源时会在请求头加上If-Modified-Since，值就是上一次的Last-Modified的值
  
  服务器比较If-Modified-Since和资源最后修改的时间，判断资源是否有变化，变化了就返回新的资源，没变化就返回304让浏览器读取本地资源

- 请求头中的If-None-Match和响应头中的Etag
  
  如果服务器1s修改资源两次，Last-Modified也只会有一个值，可能会造成缓存命中不准确
  
  Etag是根据资源生成的一个唯一标识，具体流程和上面一样，但Etag会更准确

Last-Modified和Etag同时存在时，Etag优先级更高

如果服务器要考虑负载均衡，每个服务器上Etag都不一样，那就最好不要设置Etag

工作流程：

浏览器第一次发请求，缓存了服务器返回的资源和响应头

浏览器再次发请求 

=> 有本地缓存 => 判断 Cache-Control 是否过期

               未过期 => 直接使用本地缓存

               过期 => 判断是否有 ETag

                      是 => 带 If-None-Match 请求

                      否 => 判断是否有Last-Modified

                            是 => 带If-Modified-Since 请求

                            否 => 直接向服务器请求

           

# 浏览器组成

## 1. 浏览器的理解

浏览器可以分为两部分：shell和内核

shell指浏览器的外壳：例如菜单、工具栏

内核是浏览器的核心

## 2. 浏览器内核

一般浏览器内核就是渲染引擎，负责解析和渲染网页的内容
也可以分成两部分：渲染引擎和 js 引擎
一开始渲染引擎和 js 引擎区分不明确，后来 js 引擎越来越独立，内核就倾向于只指渲染引擎

safari：webkit
chrome：以前 webkit 现在 blink
ie：trident

# 浏览器渲染原理

## 1. 浏览器的渲染过程

1. 浏览器解析收到的html，构建 DOM 树，DOM树表示网页的结构和内容
2. 浏览器解析 CSS，构建 CSSOM 规则树，CSSOM树表示网页的样式信息
3. 浏览器根据 DOM 树和 CSSOM 规则树构建渲染树，渲染树只包含需要显示的节点，渲染树的节点是渲染对象，渲染对象包含了颜色大小等属性
4. 浏览器根据渲染树的信息，计算节点的大小和位置信息，形成布局【也称为回流】
5. 浏览器遍历渲染树，调用渲染对象的 paint 方法将每个节点绘制到屏幕上
6. 浏览器将绘制好的图像传输给显示设备，显示在用户屏幕上



注意⚠️：为了更好的体验，浏览器的渲染引擎会采用渐进式渲染，也就是会尽快将内容呈现在屏幕上，并不是会等整个html都解析完再去构建渲染树

## 2. 浏览器渲染优化 ⭕️

1. 针对 javascript
   
   - 把 js 文件放在 body 后
   
   - 使用 async/defer 来异步加载 script

2. 针对 css
   
   - 导入外部样式可以用 link/@import，link 会在页面载入时同时加载，@import 会在页面载入后继续加载，优先用 link
   
   - 如果css少，尽量使用内嵌css

3. 针对DOM树和CSSOM树
   
   - html的层级不要太深
   
   - 减少css选择器的层级

4. 减少重排和重绘
   
   - 通过类名批量修改样式
   
   - 避免频繁操作DOM，可以创建一个文档片段，在它上面进行一系列操作，再插入到DOM中
   
   - 避免频繁读取布局信息，比如获取元素的尺寸位置，会触发回流
   
   - 使用css的transform属性替代定位属性，不会触发回流

## 3. 为什么我们一般把script放body后？

1. script放body后，避免在中间阻塞dom解析

2. 避免如果js中有操作dom的代码，dom树生成一半又操作了dom，会导致dom树重新生成，引起回流和重绘

## 3. 为什么我们一般把css放head里？

如果css放在body中间，前面的dom节点样式已经生成了，此时解析css文件会重新进行dom节点的样式计算，引起重绘

## 4. 什么是文档的预解析？

预先加载外部的资源

预解析不改变DOM树，只解析外部资源的引用

## 5. 什么情况会阻塞渲染？

- js阻塞渲染，遇到js代码，html解析器会暂停dom解析，因为js可能会修改生成的dom结构

- css阻塞渲染
  
  如果页面中有script脚本，script脚本的执行会等到css被解析成cssom之后，js代码才会开始执行，因为js代码可能会操作css样式，操作样式前提是有cssom

   所以css会阻塞js脚本，而js脚本会阻塞dom解析，css间接阻塞dom解析

【无论是内嵌js/外部js/内嵌css/外部css都会阻塞，外部的还要先下载才能执行，更慢】

# 浏览器本地存储

## 1. 浏览器本地存储方式

- cookie：
  纯文本文件，大小 4k 左右，浏览器每次发请求都会携带 cookie
  会话级存储，可以设置过期时间
  不能跨域，不同域的 cookie 不能共享
  
  使用场景：cookie 和 session 结合使用，把 sessionId 存在 cookie 中，每次请求携带 sessionId

- localStorage：
  大小 5m 左右
  持久存储，不主动清理就会一直存在
  不能跨域，只能同源页面共享

- sessionStorage：
  临时保存同一个窗口的数据
  关闭窗口后数据会消失
  不能跨域，只能同一窗口共享

## 2. cookie 有哪些字段，作用是什么

name、value、size、domain(可以访问此cookie的域名)、path(可以访问此cookie的页面路径)
max-age(cookie的有效期)、secure(是否使用 https 协议)、httponly(设置是否可以用脚本访问)

## 3. 前端存储的方式有哪些（浏览器存储策略）

- cookie
  兼容性好、使用方便
  大小只有 4k、每个域名有数量限制
  发请求时会自动携带
- localStorage
  操作简单、能永久性存储
- sessionStorage
  会话级存储，关闭窗口就会清除数据
- indexedDB
  nosql 数据库，键值对存储
  存储空间大，不少于 250m

三者区别：

- cookie 是服务端写入，sessionStorage 和 localStorage 由前端写入
- cookie 的生命周期是服务端写入时就设置好的，localStorage 除非手动清除一直存在，sessionStorage 页面关闭自动清除

# 浏览器的同源策略

## 1. 什么是同源策略

跨域问题就是浏览器的同源策略造成的
同源指的是：协议、域名、端口号必须一致

限制了三方面：
当前域下的不能访问其他域下的

- 当前域下的js不能访问其他域下的cookie、localStorage、indexedDB等存储性内容
- 当前域下的js不能操作其他域下的DOM节点
- ajax 不能发送跨域请求

## 2. 如何解决跨域问题 ⭕️

1. CORS 跨域资源共享
   
   - CORS是一种机制：服务器配置一些 http 响应头，来解除浏览器的跨域访问限制
   
   - CORS 分为简单请求和非简单请求：
     
     - 简单请求：浏览器发送请求会在请求头加一个 origin 字段，说明这次请求来自哪个源，服务器根据这个值，判断 origin 指定的源在不在允许范围内，然后返回响应。
       浏览器根据响应头有没有 Access-Control-Allow-Origin 字段来判断是否成功
     
     - 非简单请求：在通信之前会先发一个预检请求，请求方法是 options
       携带 origin、Access-Control-Request-Method、Access-Control-Request-Headers服务器根据这三个字段判断是否允许跨域请求。
       浏览器根据响应头有没有 Access-Control-Allow-Origin 字段来判断是否成功

【跨域请求默认不带 cookie，如果想要带要设置 withCredentials】

2. jsonp
   利用 script 标签没有跨域限制，通过 src 属性发送带 callback 参数的 get 请求。服务端调用 callback 将数据作为参数返回

   只支持 get、不安全，可能受到xss攻击

3. postMessage
   窗口之间的跨域通信
   
   postMessage()和window.addEventListener('message', )

4. nginx 反向代理
   配置一个代理服务器，域名和 domain1 一样，通过这个服务器帮我们访问 domain2，服务器之间不存在跨域

5. websocket
   本身就支持跨域

## 3. 正向代理和反向代理的区别

正：隐藏真实的客户端，客户端要发送的请求由代理服务器代发
反：隐藏真实的服务端，代理服务器收到请求后再转发到目标服务器上

# 浏览器的事件机制

## 1. 同步和异步

一个进程执行某个请求，这个请求需要等待一段时间才能返回，进程会一直等待还是执行其他请求

## 2. 对事件循环的理解

代码开始执行时，会创建一个全局执行上下文，并推入主线程的执行栈中，然后开始执行同步代码。如果执行同步代码的时候遇到异步事件，会将这个事件挂起，继续执行其他同步代码。当异步事件执行完毕后，再将异步事件对应的回调加入到任务队列中等待执行。执行栈中的代码执行完之后就会去任务队列读取任务压入栈中执行
任务队列分为宏任务队列和微任务队列，执行完一个宏任务就会检查微任务队列是否为空，不为空就一次性执行完所有微任务，
下一次循环再取第一个宏任务执行

具体：先从整块代码开始第一次执行，同步代码(属于宏任务) => 所有微任务 => 下一个宏任务

## 3. 宏任务和微任务

宏任务：同步代码、setTimeout、setInterval、dom渲染
微任务：promise 的 then()、await 语句后、node 中的process.nextTick、

## 4. 什么是执行栈

执行栈：用来管理执行上下文的
js 执行代码，遇到全局代码会创建全局执行上下文，压入执行上下文栈
每遇到一个函数调用，就创建一个函数执行上下文，压入栈，函数执行完之后，就会从栈中弹出
继续执行下一个执行上下文
所有代码执行完之后，从栈中弹出全局执行上下文

## 5. node 中的事件循环

分 6 个阶段，进入某一个阶段的时候，都会从对应的回调队列中取出函数执行
队列为空才进入下个阶段

- timers 阶段
  执行 setTimeout 和 setInterval 回调，
  如果回调中触发了微任务，执行完所有回调之后再执行微任务
- pending callbacks
  执行上一轮事件循环遗留的 I/O 回调
- idle/prepare
  给系统内部使用
- poll 轮询阶段
  对应的回调队列不为空的时候，就执行回调，如果回调触发了微任务，会在每个回调执行完之后执行对应的微任务，而不是等所有回调都执行完才执行
  对应的回调队列为空的时候，如果有计时器没执行，就会结束轮询进入 check 阶段。否则会阻塞并等待正在执行的 I/O 操作完成
- check 阶段
  执行 setImmediate 回调，
  如果回调中触发了微任务，执行完所有回调之后再执行微任务
- close callbacks
  执行一些关闭回调

还有一个 process.nextTick，独立于事件循环之外
有一个自己的队列，每个阶段完成后，会清空 nextTick 队列，并且是**比微任务优先清空的**
